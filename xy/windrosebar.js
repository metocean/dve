// Generated by CoffeeScript 1.9.3

/*

Plot a windrose with additional categories for each direction.

TODO: Work out how to position these xy visualisations.
TODO: Allow the different categories and values to be specified.
 */
var calculate_layout, d3;

d3 = require('d3');

calculate_layout = function(dimensions, spec) {
  var container, inner, innerAspectRatio, innerMargin, legend, maxContainerWidth, minContainerWidth;
  inner = {};
  innerMargin = {
    top: 30,
    right: 50,
    bottom: 65,
    left: 80
  };
  legend = {
    top: 20,
    width: 130
  };
  legend.height = legend.height = (spec.bins.length + 1.5) * 30;
  legend.bottom = legend.top + legend.height;
  maxContainerWidth = 900;
  minContainerWidth = 520;
  container = {};
  container.width = Math.min(dimensions[0], maxContainerWidth);
  container.right = container.width;
  container.left = 0;
  legend.right = container.width;
  legend.left = legend.right - legend.width;
  inner.right = container.right - legend.width - innerMargin.right;
  inner.left = 0 + innerMargin.left;
  inner.width = inner.right - inner.left;
  innerAspectRatio = 0.5;
  inner.height = innerAspectRatio * inner.width;
  inner.top = 0 + innerMargin.top;
  inner.bottom = inner.top + inner.height;
  container.height = Math.max(inner.bottom + innerMargin.bottom, legend.bottom);
  return {
    container: container,
    inner: inner,
    legend: legend
  };
};

module.exports = function(spec, components) {
  var result;
  return result = {
    render: function(dom, state, params) {
      var axis, bars, bin, chart, colorScale, d, dataMax, groupedData, i, inner, j, k, l, layout, legend, legendHeading, legendRectSize, legendSpacing, len, len1, m, nBins, nCategories, obj, ref, ref1, results, scale, sobj, start, svg;
      layout = calculate_layout(params.dimensions, spec);
      svg = d3.select(dom).append('svg').attr('class', 'item windrosebar');
      nCategories = state.data.length;
      nBins = spec.bins.length;
      groupedData = [];
      ref = state.data;
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        d = ref[i];
        obj = {};
        obj.angle = i * (360 / nCategories);
        obj.key = obj.angle;
        obj.category = d[spec.category];
        obj.value = obj.category;
        obj.speeds = [];
        start = 0;
        ref1 = spec.bins;
        for (j = l = 0, len1 = ref1.length; l < len1; j = ++l) {
          bin = ref1[j];
          sobj = {};
          sobj.index = j;
          sobj.start = start;
          start += +d[bin];
          sobj.end = start;
          obj.speeds.push(sobj);
        }
        obj.count = start;
        groupedData.push(obj);
      }
      dataMax = d3.max((function() {
        var len2, m, results;
        results = [];
        for (m = 0, len2 = groupedData.length; m < len2; m++) {
          d = groupedData[m];
          results.push(d.count);
        }
        return results;
      })());
      inner = svg.append('g').attr('class', 'inner').attr('transform', "translate(" + layout.inner.left + "," + layout.inner.top + ")");
      inner.append('g').attr('class', 'x axis').attr('transform', "translate(0," + layout.inner.height + ")");
      inner.append('g').attr('class', 'y axis');
      chart = inner.append('g').attr('class', 'chart');
      chart.append('defs').append('rect').attr('x', '0').attr('y', '0').attr('width', layout.inner.width).attr('height', layout.inner.height);
      colorScale = d3.scale.quantize().range(['#E4EAF1', '#D1D8E3', '#BEC7D5', '#ABB6C7', '#98A5B9', '#8594AB', '#73829E', '#607190', '#4D6082', '#3A4E74', '#273D66', '#142C58', '#122851', '#102448']).domain([0, nBins]);
      scale = {
        x: d3.scale.ordinal().domain(groupedData.map(function(d) {
          return d.value;
        })),
        y: d3.scale.linear().domain([
          0, 1.1 * d3.max(groupedData, function(d) {
            return d.count;
          })
        ])
      };
      axis = {
        x: d3.svg.axis().scale(scale.x).orient('bottom'),
        y: d3.svg.axis().scale(scale.y).orient('left')
      };
      svg.attr('width', layout.container.width).attr('height', layout.container.height);
      scale.x.rangeRoundBands([0, layout.inner.width], 0.05);
      scale.y.range([layout.inner.height, 0]);
      bars = chart.selectAll('.bar').data(groupedData).enter().append('g').attr('class', 'bar').attr('transform', function(d) {
        return "translate(" + (scale.x(d.value)) + ", 0)";
      });
      bars.selectAll('rect').data(function(d) {
        return d.speeds;
      }).enter().append('rect').attr('x', 0).attr('y', function(d) {
        return scale.y(d.end);
      }).attr("width", scale.x.rangeBand()).attr('height', function(d) {
        return scale.y(d.start) - scale.y(d.end);
      }).style('fill', function(d) {
        return colorScale(d.index);
      });
      inner.select('.x.axis').call(axis.x);
      inner.select('.y.axis').call(axis.y.tickSize(-layout.inner.width, 0, 0));
      inner.selectAll('.y.axis .tick line').data(scale.y.ticks(axis.y.ticks()[0])).attr('class', function(d) {
        if (d === 0) {
          return 'zero';
        } else {
          return null;
        }
      });
      inner.select('.y.axis .domain').remove();
      inner.append('text').attr('x', layout.inner.width / 2).attr('y', layout.inner.height + 30).attr('dy', '1em').attr('class', 'axis-label axis-label--x').style('text-anchor', 'middle').text(spec.xLabel);
      inner.append('text').attr('text-anchor', 'middle').attr('x', -1 * (layout.inner.height / 2)).attr('y', -50).attr('dy', '1em').attr('transform', 'rotate(-90)').attr('class', 'axis-label axis-label--y').text(spec.yLabel);
      legendRectSize = 20;
      legendSpacing = 10;
      legend = svg.selectAll('.legend').data((function() {
        results = [];
        for (var m = 0; 0 <= nBins ? m < nBins : m > nBins; 0 <= nBins ? m++ : m--){ results.push(m); }
        return results;
      }).apply(this)).enter().append('g').attr('class', 'legend').attr('transform', function(d, i) {
        return "translate(" + layout.legend.left + "," + (layout.legend.top + (legendRectSize + legendSpacing) * i + 30) + ")";
      });
      legend.append('rect').attr('width', legendRectSize).attr('height', legendRectSize).style('fill', colorScale).style('stroke', colorScale);
      legend.append('text').attr('x', legendRectSize + legendSpacing).attr('y', legendRectSize - legendSpacing + 5).text(function(d) {
        return spec.bins[d];
      });
      return legendHeading = svg.append('text').attr('x', layout.legend.left).attr('y', layout.legend.top).attr('dy', '1em').text(spec.binLabel);
    }
  };
};
