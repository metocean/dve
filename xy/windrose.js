// Generated by CoffeeScript 1.9.3

/*

Plot a windrose with additional categories for each direction.

TODO: Work out how to position these xy visualisations.
TODO: Allow the different categories and values to be specified.
 */
var calculate_layout, d3;

d3 = require('d3');

calculate_layout = function(dimensions) {
  var container, inner, innerMargin, legend;
  console.log('rose dimensions', dimensions);
  container = {
    width: 600
  };
  legend = {
    height: 200,
    width: 100
  };
  legend.top = 0;
  legend.bottom = legend.top + legend.height;
  innerMargin = {
    top: 25,
    right: 20,
    bottom: 20,
    left: 20
  };
  inner = {
    left: innerMargin.left,
    right: container.width - legend.width - innerMargin.right,
    top: innerMargin.top
  };
  inner.width = inner.right - inner.left;
  inner.height = inner.width;
  inner.bottom = inner.top + inner.height;
  container.height = inner.height + innerMargin.top + innerMargin.bottom;
  return {
    container: container,
    inner: inner,
    legend: legend
  };
};

module.exports = function(spec, components) {
  var result;
  return result = {
    render: function(dom, state, params) {
      var arc, axis, bin, circlecontainer, colorScale, d, dataMax, diameter, groupedData, i, inner, j, k, l, layout, len, len1, m, nCategories, nTicks, obj, radialScale, ref, ref1, ref2, results, scale, segment, sobj, start, svg, textcolorScale;
      layout = calculate_layout(params.dimensions);
      console.log('layout', layout);
      svg = d3.select(dom).append('svg').attr('class', 'item windrose');
      console.log('crunching data');
      nCategories = state.data.length;
      groupedData = [];
      ref = state.data;
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        d = ref[i];
        obj = {};
        obj.angle = i * (360 / nCategories);
        obj.key = obj.angle;
        obj.category = d[spec.category];
        obj.value = obj.category;
        obj.speeds = [];
        start = 0;
        ref1 = spec.bins;
        for (j = l = 0, len1 = ref1.length; l < len1; j = ++l) {
          bin = ref1[j];
          sobj = {};
          sobj.index = j;
          sobj.start = start;
          start += +d[bin];
          sobj.end = start;
          obj.speeds.push(sobj);
        }
        obj.count = start;
        groupedData.push(obj);
      }
      dataMax = d3.max((function() {
        var len2, m, results;
        results = [];
        for (m = 0, len2 = groupedData.length; m < len2; m++) {
          d = groupedData[m];
          results.push(d.count);
        }
        return results;
      })());
      svg.attr('width', layout.container.width).attr('height', layout.container.height);
      inner = svg.append('g').attr('class', 'inner').attr('transform', "translate(" + (layout.inner.left + layout.inner.width / 2) + "," + (layout.inner.top + layout.inner.height / 2) + ")");
      colorScale = d3.scale.quantize().range(['#E4EAF1', '#D1D8E3', '#BEC7D5', '#ABB6C7', '#98A5B9', '#8594AB', '#73829E', '#607190', '#4D6082', '#3A4E74', '#273D66', '#142C58', '#122851', '#102448']).domain([0, nCategories]);
      textcolorScale = d3.scale.quantize().range(['#000000', '#000000', '#ffffff', '#ffffff']).domain([0, nCategories]);
      console.log('building scale');
      scale = d3.scale.linear().domain([
        0, 1.1 * d3.max(groupedData, function(d) {
          return d.count;
        })
      ]).range([0, layout.inner.width / 2]);
      diameter = (scale(scale.domain()[1])) - 5;
      circlecontainer = inner.append('g').attr('class', 'circlecontainer');
      console.log('making axis', axis);
      axis = inner.selectAll('.axis').data(groupedData).enter().append('g').attr('class', 'axis').attr('transform', function(d) {
        return "rotate(" + d.key + ")";
      });
      console.log('making arc', arc);
      arc = function(o) {
        return d3.svg.arc().startAngle(function(d) {
          return (-o.width / 2) * Math.PI / 180;
        }).endAngle(function(d) {
          return (+o.width / 2) * Math.PI / 180;
        }).innerRadius(o.from).outerRadius(o.to);
      };
      axis.append('line').attr('class', 'spoke').attr('x1', scale(0)).attr('y1', scale(0)).attr('x2', scale(0)).attr('y2', layout.inner.width / 2);
      axis.append('g').attr('transform', function(d) {
        return "translate(" + (scale(0)) + "," + (layout.inner.height * (-0.53)) + ")";
      }).append('text').attr('transform', function(d) {
        return "rotate(" + (-d.key) + ")";
      }).attr('style', 'text-anchor: middle').attr('dy', '0.25em').text(function(d) {
        return d.value;
      });
      console.log('sevment', segment);
      segment = inner.selectAll('.segment').data(groupedData).enter().append('g').attr('class', 'segment').attr('transform', function(d) {
        return "rotate(" + d.key + ")";
      }).selectAll('path').data(function(d) {
        return d.speeds;
      }).enter().append('path').attr('d', arc({
        width: 360 / nCategories * 0.8,
        from: function(d) {
          return scale(d.start);
        },
        to: function(d) {
          return scale(d.end);
        }
      })).style('fill', function(d) {
        return colorScale(d.index);
      });
      nTicks = 4;
      radialScale = d3.scale.linear().domain([0, nTicks]).range([0, dataMax]);
      console.log('making circles');
      results = [];
      for (i = m = 1, ref2 = nTicks + 1; 1 <= ref2 ? m < ref2 : m > ref2; i = 1 <= ref2 ? ++m : --m) {
        circlecontainer.append('text').text(+radialScale(i).toPrecision(5)).attr('x', 0).attr('y', -(i * diameter / nTicks));
        results.push(circlecontainer.append('circle').attr('cx', 0).attr('cy', 0).attr('r', i * diameter / nTicks));
      }
      return results;
    }
  };
};
