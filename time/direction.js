// Generated by CoffeeScript 1.9.1

/*

Shows a series of directional arrows.
Useful for current and wind direction.
Scales number of arrows depending on space.

TODO: Implement more dynamic scalling.
 */
var calculate_layout, d3, moment, neighbours,
  modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

d3 = require('d3');

moment = require('timespanner');

neighbours = require('../util/neighbours');

calculate_layout = function(dimensions) {
  var canvas, info, title;
  dimensions = {
    width: dimensions[0],
    height: 60
  };
  info = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 200
  };
  title = {
    top: 0,
    right: dimensions.width - info.left,
    bottom: 0,
    left: 0,
    height: dimensions.height,
    width: info.left
  };
  canvas = {
    top: info.top,
    right: info.right,
    bottom: info.bottom,
    left: info.left,
    width: dimensions.width - info.left - info.right,
    height: dimensions.height - info.top - info.bottom
  };
  return {
    dimensions: dimensions,
    info: info,
    title: title,
    canvas: canvas
  };
};

module.exports = function(dom, options) {
  var calculate_direction, components, create_directions, data, dimensions, domain, drag, drawArrow, filteredData, focus, hub, inner, layout, poi, poifsm, resize, scale, sections, spec, svg, updatepoi;
  components = options.components, spec = options.spec, dimensions = options.dimensions, data = options.data, domain = options.domain, hub = options.hub;
  layout = calculate_layout(dimensions);
  sections = null;
  drawArrow = function(dir, section) {
    var arrow;
    section.selectAll('*').remove();
    arrow = section.append('g').attr('transform', 'rotate(' + (dir + 180) + ', 0, 10)');
    arrow.append('path').attr('class', 'arrowhead').attr('d', d3.svg.symbol().type('triangle-up').size(20));
    arrow.append('line').attr('class', 'arrowline').attr('x1', 0).attr('x2', 0).attr('y1', 3).attr('y2', 20);
    return section.append('text').attr('class', 'label').text("" + (dir.toFixed(0)) + spec.units).attr('text-anchor', 'middle').attr('transform', "translate(0,35)");
  };
  create_directions = function() {
    var arrow, bisector, section;
    bisector = d3.bisector(function(d) {
      return d.time;
    }).left;
    data = scale.ticks(d3.time.hour, 3).map(function(d) {
      var index;
      index = bisector(filteredData, d);
      return filteredData[index];
    }).filter(function(d) {
      return d != null;
    });
    sections = svg.select('.inner').selectAll('.section').data(data);
    section = sections.enter().append('g').attr('class', function(d) {
      var hour;
      hour = d.time.local().get('hour');
      if (hour % 12 === 0) {
        return 'section priority1';
      } else if (hour % 6 === 0) {
        return 'section priority2';
      } else if (hour % 3 === 0) {
        return 'section priority3';
      }
    });
    arrow = section.append('g').attr('transform', function(d) {
      return "rotate(" + (d[spec.field] + 180) + ", 0, 9)";
    });
    arrow.append('path').attr('class', 'arrowhead').attr('d', d3.svg.symbol().type('triangle-up').size(20));
    arrow.append('line').attr('class', 'arrowline').attr('x1', 0).attr('x2', 0).attr('y1', 3).attr('y2', 20);
    return section.append('text').attr('class', 'label').text(function(d) {
      return calculate_direction(d[spec.field]);
    }).attr('text-anchor', 'middle').attr('transform', "translate(0,40)");
  };
  resize = function(dimensions) {
    var minLabelWidth, p1, p1widths, p2, p2widths, p3, p3widths;
    layout = calculate_layout(dimensions);
    svg.attr('width', layout.dimensions.width).attr('height', layout.dimensions.height);
    scale.range([0, layout.canvas.width]);
    sections.attr('transform', function(d) {
      return "translate(" + (scale(d.time)) + ", 10)";
    });
    p1 = inner.selectAll('.priority1');
    p2 = inner.selectAll('.priority2');
    p3 = inner.selectAll('.priority3');
    minLabelWidth = 31;
    p1widths = p1[0].length * minLabelWidth;
    p2widths = p2[0].length * minLabelWidth;
    p3widths = p3[0].length * minLabelWidth;
    switch (false) {
      case !(p1widths + p2widths + p3widths <= layout.canvas.width):
        p2.attr('display', 'inline');
        p3.attr('display', 'inline');
        break;
      case !(p1widths + p2widths <= layout.canvas.width):
        p2.attr('display', 'inline');
        p3.attr('display', 'none');
        break;
      case !(p1widths <= layout.canvas.width):
        p3.attr('display', 'none');
        p2.attr('display', 'none');
    }
    return updatepoi();
  };
  calculate_direction = function(degree) {
    var direction, text, textDirection;
    direction = Math.floor((degree / 22.5) + 0.5);
    text = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
    return textDirection = text[modulo(direction, 16)];
  };
  svg = d3.select(dom).append('svg').attr('class', 'item direction');
  data = data.map(function(d) {
    var result;
    result = {
      time: d.time
    };
    result[spec.field] = +d[spec.field];
    return result;
  });
  svg.append('g').attr('class', 'title').attr('transform', "translate(" + layout.title.left + "," + layout.title.top + ")").append('text').attr('class', 'infotext').text(spec.text).attr('dy', 18).attr('dx', 5);
  inner = svg.append('g').attr('class', 'inner').attr('transform', "translate(" + layout.canvas.left + "," + layout.canvas.top + ")");
  inner.append('line').attr('class', 'divider').attr('x1', 0).attr('x2', 0).attr('y1', 0).attr('y2', layout.dimensions.height);
  filteredData = data.filter(function(d) {
    return +d.time >= +domain[0] && +d.time <= +domain[1];
  });
  scale = d3.time.scale().domain(domain).range([0, layout.canvas.width]);
  create_directions();
  focus = inner.append('g').attr('class', 'focus');
  focus.append('line').attr('class', 'poi').attr('display', 'none').attr('y1', 0).attr('y2', layout.dimensions.height);
  focus.append('circle').attr('class', 'arrow-background').attr('r', 25).attr('display', 'none');
  focus.append('g').attr('class', 'foc-section').attr('display', 'none');
  poi = null;
  hub.on('poi', function(p) {
    poi = p;
    return updatepoi();
  });
  poifsm = {
    hide: function() {
      if (poi === null) {
        return;
      }
      return hub.emit('poi', null);
    },
    show: function(x) {
      var d, range;
      range = scale.range();
      if (range[0] > x || range[1] < x) {
        return poifsm.hide();
      }
      d = scale.invert(x);
      if (poi === d) {
        return;
      }
      return hub.emit('poi', moment.utc(d));
    },
    update: function() {
      var dist, x;
      x = d3.mouse(inner.node())[0];
      if (poifsm.startx != null) {
        dist = Math.abs(poifsm.startx - x);
        if (dist < 10) {
          return;
        }
      }
      poifsm.startx = null;
      return poifsm.show(x);
    },
    mousedown: function() {
      var x;
      x = d3.mouse(inner.node())[0];
      if (poifsm.currentx == null) {
        return poifsm.show(x);
      }
      return poifsm.startx = x;
    },
    mouseup: function() {
      var dist, x;
      if (poifsm.startx == null) {
        return;
      }
      if (!poifsm.currentx) {
        poifsm.startx = null;
        return poifsm.hide();
      }
      dist = Math.abs(poifsm.startx - poifsm.currentx);
      if (dist < 10) {
        poifsm.startx = null;
        return poifsm.hide();
      }
      x = d3.mouse(inner.node())[0];
      return poifsm.show(x);
    }
  };
  drag = d3.behavior.drag().on('drag', poifsm.update);
  focus.append('rect').attr('class', 'foreground').attr('height', layout.canvas.height).attr('width', layout.canvas.width).style('fill', 'none').on('mousedown', poifsm.mousedown).on('mouseup', poifsm.mouseup).call(drag);
  updatepoi = function() {
    var Neighbours, d, d0, d1, halfway, poiNeighbours, xVal;
    if (poi == null) {
      focus.select('line.poi').attr('display', 'none');
      focus.select('.foc-section').attr('display', 'none');
      focus.select('.arrow-background').attr('display', 'none');
      return;
    }
    poifsm.currentx = scale(poi);
    focus.select('line.poi').attr('display', null).attr('x1', scale(poi)).attr('x2', scale(poi));
    Neighbours = neighbours(filteredData, function(d) {
      return d.time;
    });
    poiNeighbours = Neighbours(poi);
    d;
    if (poiNeighbours.length === 1) {
      d = poiNeighbours[0];
    } else if (+poiNeighbours[0].time < +domain[0]) {
      d = poiNeighbours[1];
    } else if (+poiNeighbours[1].time > +domain[1]) {
      d = poiNeighbours[0];
    } else {
      d0 = poiNeighbours[0];
      d1 = poiNeighbours[1];
      halfway = d0.time + (d1.time - d0.time) / 2;
      d = poi.isBefore(halfway) ? d0 : d1;
    }
    drawArrow(d[spec.field], focus.select('.foc-section'));
    if ((layout.canvas.width - scale(poi)) < 27) {
      xVal = layout.canvas.width - 27;
    } else if ((layout.canvas.left + scale(poi)) < 227) {
      xVal = 27;
    } else {
      xVal = scale(d.time);
    }
    focus.select('.arrow-background').attr('display', null).attr('transform', "translate(" + xVal + ", " + (layout.canvas.height / 2) + ")");
    return focus.select('.foc-section').attr('display', null).attr('transform', "translate(" + xVal + ", " + ((layout.canvas.height / 2) - 17) + ")");
  };
  resize(dimensions);
  return {
    resize: resize
  };
};
