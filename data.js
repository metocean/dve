// Generated by CoffeeScript 1.9.1
var createhub, d3, moment;

d3 = require('d3');

moment = require('moment');

createhub = require('./util/hub');

module.exports = function(dom, options) {
  var components, dimensions, items, spec;
  components = options.components, spec = options.spec, dimensions = options.dimensions;
  items = [];
  d3.csv(spec.source.url, function(error, data) {
    var d, domain, durationformats, end, fn, fn1, hub, j, k, l, len, len1, len2, name, parse, parse_duration, parse_end, parse_start, parse_time, poi, ref, ref1, s, source, start, target, timeRegex, value;
    if (spec.source.translate != null) {
      for (j = 0, len = data.length; j < len; j++) {
        d = data[j];
        ref = spec.source.translate;
        for (target in ref) {
          source = ref[target];
          if (d[source] == null) {
            continue;
          }
          value = d[source];
          delete d[source];
          d[target] = value;
        }
      }
    }
    if (spec.source.include != null) {
      data = data.filter(function(d) {
        var key, ref1, shouldinclude;
        shouldinclude = true;
        ref1 = spec.source.include;
        for (key in ref1) {
          value = ref1[key];
          if (d[key] == null) {
            continue;
          }
          shouldinclude = shouldinclude && d[key] === value;
        }
        return shouldinclude;
      });
    }
    if (spec.source.exclude != null) {
      data = data.filter(function(d) {
        var key, ref1, shouldexclude;
        shouldexclude = false;
        ref1 = spec.source.exclude;
        for (key in ref1) {
          value = ref1[key];
          if (d[key] == null) {
            continue;
          }
          shouldexclude = shouldexclude && d[key] === value;
        }
        return !shouldexclude;
      });
    }
    parse_time = function(time) {
      return moment.utc(d.time, moment.ISO_8601);
    };
    if (spec.source.timeformat != null) {
      parse_time = function(time) {
        return moment.utc(d.time, spec.source.timeformat);
      };
    }
    for (k = 0, len1 = data.length; k < len1; k++) {
      d = data[k];
      d.time = parse_time(d.time);
    }
    domain = d3.extent(data, function(d) {
      return d.time;
    });
    timeRegex = /(\-|\+)[0-9]+([dwMyhms])/;
    start = spec.display.start;
    end = spec.display.end;
    parse_start = function(time) {
      return moment.utc(time, moment.ISO_8601);
    };
    parse_end = function(time) {
      return moment.utc(time, moment.ISO_8601);
    };
    parse_duration = function(str) {
      var duration, offset, offsetunit, sign;
      sign = str.substr(0, 1);
      offset = +str.substr(1, str.length - 2);
      offsetunit = str.substr(str.length - 1);
      if (sign === '-') {
        offset = -offset;
      }
      return duration = moment.duration(offset, offsetunit);
    };
    durationformats = {
      timestamp: function(str) {
        var duration;
        duration = parse_duration(str);
        return moment.utc().add(duration);
      },
      second: function(str) {
        var duration;
        duration = parse_duration(str);
        return moment.utc().startOf('second').add(duration);
      },
      minute: function(str) {
        var duration;
        duration = parse_duration(str);
        return moment.utc().startOf('minute').add(duration);
      },
      hour: function(str) {
        var duration;
        duration = parse_duration(str);
        return moment.utc().startOf('hour').add(duration);
      },
      day: function(str) {
        var duration;
        duration = parse_duration(str);
        return moment.utc().startOf('day').add(duration);
      },
      week: function(str) {
        var duration;
        duration = parse_duration(str);
        return moment.utc().startOf('week').add(duration);
      },
      month: function(str) {
        var duration;
        duration = parse_duration(str);
        return moment.utc().startOf('month').add(duration);
      },
      year: function(str) {
        var duration;
        duration = parse_duration(str);
        return moment.utc().startOf('year').add(duration);
      },
      localsecond: function(str) {
        var duration;
        duration = parse_duration(str);
        return moment().startOf('second').add(duration).utc();
      },
      localminute: function(str) {
        var duration;
        duration = parse_duration(str);
        return moment().startOf('minute').add(duration).utc();
      },
      localhour: function(str) {
        var duration;
        duration = parse_duration(str);
        return moment().startOf('hour').add(duration).utc();
      },
      localday: function(str) {
        var duration;
        duration = parse_duration(str);
        return moment().startOf('day').add(duration).utc();
      },
      localweek: function(str) {
        var duration;
        duration = parse_duration(str);
        return moment().startOf('week').add(duration).utc();
      },
      localmonth: function(str) {
        var duration;
        duration = parse_duration(str);
        return moment().startOf('month').add(duration).utc();
      },
      localyear: function(str) {
        var duration;
        duration = parse_duration(str);
        return moment().startOf('year').add(duration).utc();
      }
    };
    if (start != null) {
      if (typeof start === 'string') {
        fn = function(name, parse) {
          return parse_start = function(time) {
            return parse(start.slice(name.length));
          };
        };
        for (name in durationformats) {
          parse = durationformats[name];
          if (start.indexOf(name) !== 0) {
            continue;
          }
          fn(name, parse);
          break;
        }
        domain[0] = parse_start(start);
      } else {
        domain[0] = start;
      }
    }
    if (end != null) {
      if (typeof start === 'string') {
        fn1 = function(name, parse) {
          return parse_end = function(time) {
            return parse(end.slice(name.length));
          };
        };
        for (name in durationformats) {
          parse = durationformats[name];
          if (end.indexOf(name) !== 0) {
            continue;
          }
          fn1(name, parse);
          break;
        }
        domain[1] = parse_end(end);
      } else {
        domain[1] = end;
      }
    }
    poi = null;
    if (moment.utc().isBetween(domain[0], domain[1])) {
      poi = moment.utc();
    }
    hub = createhub();
    ref1 = spec.spec;
    for (l = 0, len2 = ref1.length; l < len2; l++) {
      s = ref1[l];
      if (components[s.type] == null) {
        return console.error(s.type + " component not found");
      }
      items.push(components[s.type](dom, {
        components: components,
        spec: s,
        dimensions: dimensions,
        hub: hub,
        data: data,
        domain: domain
      }));
    }
    return hub.emit('poi', poi);
  });
  return {
    resize: function(dimensions) {
      var i, j, len, results;
      results = [];
      for (j = 0, len = items.length; j < len; j++) {
        i = items[j];
        if (i.resize == null) {
          continue;
        }
        results.push(i.resize(dimensions));
      }
      return results;
    }
  };
};
